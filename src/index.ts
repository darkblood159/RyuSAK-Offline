import { app, BrowserWindow, shell, session, ipcMain, screen, autoUpdater } from "electron";
import isDev from "electron-is-dev";
import makeIpcRoutes from "./main/routes/index";
import path from "path";
import child_process from "child_process";
import fs from "fs-extra";

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

export const hasPortableFile = fs.existsSync(path.resolve(app.getPath("exe"), "..", "portable"));
export const cacheDir = hasPortableFile ? path.resolve(app.getPath("exe"), "..", "electron_cache") : path.join(app.getPath("userData"));
export const proxyFile = path.resolve(cacheDir, "proxy");
export const SYS_SETTINGS = {
  proxy: readFile(proxyFile),
};
let updateDownloaded = false;

function readFile(path: string): string {
  try {
    return fs.readFileSync(path, "utf-8");
  } catch (e) {
    return "";
  }
}

ipcMain.handle("check-status", () => updateDownloaded);

// Don't use appData to store cache if portable mode is enabled
if (hasPortableFile) {
  fs.ensureDirSync(cacheDir);
  app.setPath("userData", cacheDir);
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) { // eslint-disable-line global-require
  app.quit();
}

const gotTheLock = app.requestSingleInstanceLock();
let mainWindow: BrowserWindow;

const handleStartupEvent = function () {
  if (process.platform !== "win32") {
    return false;
  }

  const appFolder = path.resolve(process.execPath, "..");
  const rootAtomFolder = path.resolve(appFolder, "..");
  const updateDotExe = path.resolve(path.join(rootAtomFolder, "Update.exe"));
  const exeName = path.basename(process.execPath);

  const spawn = function (command: any, args: any) {
    let spawnedProcess;

    try {
      spawnedProcess = child_process.spawn(command, args, { detached: true });
    } catch (error) {
      console.error(error);
    }

    return spawnedProcess;
  };

  const spawnUpdate = function (args: any) {
    return spawn(updateDotExe, args);
  };

  const squirrelCommand = process.argv[1];
  switch (squirrelCommand) {
    case "--squirrel-install":
      spawnUpdate(["--createShortcut", exeName]);
      return false;
    case "--squirrel-updated":
      setTimeout(app.quit, 1000);
      return true;
    case "--squirrel-uninstall":
      app.quit();
      try {
        fs.removeSync(app.getPath("userData"));
      } catch (e) {
        console.error(e);
      }
      spawnUpdate(["--removeShortcut", exeName]);
      return true;
    case "--squirrel-obsolete":
      app.quit();
      return true;
  }
};

if (handleStartupEvent()) {
  process.exit(0);
}

const createWindow = (): void => {
  mainWindow = new BrowserWindow({
    title: `${app.getName()} v${app.getVersion()}`,
    autoHideMenuBar: true,
    show: false,
    minHeight: 680,
    minWidth: 920,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    }
  });

  makeIpcRoutes(mainWindow);

  mainWindow.webContents.on("did-finish-load", function () {
    const displays = screen.getAllDisplays();
    const display = displays.find((d) => d.bounds.x !== 0 || d.bounds.y !== 0) || displays[0];

    mainWindow.setSize(Math.min(display.bounds.width, 1280), Math.min(display.bounds.width, 860));
    mainWindow.center();
    mainWindow.show();

    if (hasPortableFile) {
      mainWindow.webContents.send("is-portable");
    } else if (!isDev && process.platform === "win32") {
      const feed = `https://update.electronjs.org/Ecks1337/RyuSAK/${process.platform}-${process.arch}/${app.getVersion()}`;

      try {
        autoUpdater.setFeedURL({ url: feed });

        // Check updates every 10 min, and at startup
        setInterval(() => {
          autoUpdater.checkForUpdates();
        }, 10 * 60 * 1000);

        autoUpdater.checkForUpdates();

        autoUpdater.on("update-available", () => mainWindow.webContents.send("update-available"));
        autoUpdater.on("update-downloaded", () => {
          updateDownloaded = true;
          mainWindow.webContents.send("update-downloaded");
        });
        ipcMain.on("reboot-after-download", () => autoUpdater.quitAndInstall());
      } catch (error) {
        console.error('AutoUpdater error:', error.message);
      }
    }
  });

  mainWindow.webContents.on('new-window' as any, function (e: { preventDefault: () => void; }, url: string) {
    e.preventDefault();
    shell.openExternal(url);
  });

  mainWindow.on('page-title-updated', function (e) {
    e.preventDefault();
  });

  if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL);
  } else {
    mainWindow.loadFile(path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`));
  };

  let cspHeader = "default-src 'self' https://fonts.googleapis.com/ https://fonts.gstatic.com/ 'unsafe-inline'; img-src 'self' data: https://*;";

  // "unsafe-eval" is required by webpack in development
  if (process.env.NODE_ENV === "development") {
    cspHeader = "default-src 'self' https://fonts.googleapis.com/ https://fonts.gstatic.com/ 'unsafe-inline' 'unsafe-eval'; img-src 'self' data: https://*;";
  }

  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        "Content-Security-Policy": [cspHeader]
      }
    });
  });

  // Ensure the window is shown even if it fails to load initially
  setTimeout(() => {
    if (!mainWindow.isVisible()) {
      console.warn('Forcing window to show after timeout');
      mainWindow.show();
    }
  }, 5000);
};

// Do not allow application to be launched twice
if (!gotTheLock) {
  app.quit();
} else {
  app.on("second-instance", () => {
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });

  // This method will be called when Electron has finished
  // initialization and is ready to create browser windows.
  // Some APIs can only be used after this event occurs.
  app.on("ready", createWindow);
}

app.on("window-all-closed", () => {
  app.quit();
});

// Global exception handler to ignore specific errors
process.on('uncaughtException', (error) => {
  if (error.message.includes('Cannot find Squirrel')) {
    console.log('Ignoring Squirrel error:', error.message);
  } else {
    console.error('Unhandled exception:', error);
  }
});
